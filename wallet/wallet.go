package wallet

import (
	"crypto/ecdsa"
)

const version = byte(0x00)

// A structure that represents a wallet to access the blockchain
type Wallet struct {
	PrivateKey ecdsa.PrivateKey // Represetns the Public Key of the Wallet
	PublicKey  []byte           // Represents the Private Key of the Wallet
}

// A constructor function that generates and returns a Wallet
func NewWallet() *Wallet {
	// Generate private-public key pair
	private, public := GenerateWalletKeys()
	// Assign the keys to the wallet fields
	wallet := Wallet{PrivateKey: private, PublicKey: public}
	// Return the wallet
	return &wallet
}

/*
A method of Wallet that generates and returns the address
of the wallet as a slice of bytes.

The address generation is done by double hashing the public key with
SHA256 and trunctuated to 20 bytes. This is equivalent to the hashing
SHA256 and then RIPEMD160 after that because the original bitcoins papers
do not elaborate on Satoshi Nakomoto's original decision to use the RIPEMD160
algorithm over the SHA1 which both create a 20 byte hash. Trunctuation of the
SHA256 hash to 20 bytes is just as secure and achieves the same purpose.
A checksum hash is then generated by double hashing public key hash and
taking the first 4 bytes of. The checksum is combined with the public hash
and a version byte to create the final hash which is encoded to base58
and returned as the wallet address.

References:

https://bitcoin.stackexchange.com/questions/16543/why-was-the-ripemd-160-hash-algorithms-chosen-before-sha-1

https://crypto.stackexchange.com/questions/3153/sha-256-vs-any-256-bits-of-sha-512-which-is-more-secure
*/
func (w *Wallet) GenerateAddress() []byte {
	// Generate the double hash of the public key
	publichash := GenerateDoubleHash(w.PublicKey)
	// Trunctuate the public key hash to 20 bytes
	publichash = TruncuateHash(publichash, 20)

	// Generate the checksum hash by double hashing the puclic key hash
	checksumhash := GenerateDoubleHash(publichash)
	// Truncuate the checksum hash to 4 bytes
	checksumhash = TruncuateHash(checksumhash, 4)

	// Add the version byte, public key hash and checksum hash
	finalhash := append([]byte{version}, publichash...)
	finalhash = append(finalhash, checksumhash...)

	// Encode the final hash to base58
	address := Base58Encode(finalhash)
	// Return the address
	return address
}
