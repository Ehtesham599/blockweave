package wallet

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"log"

	"github.com/mr-tron/base58/base58"
)

// A function to handle errors.
func Handle(err error) {
	// Check if error is non null
	if err != nil {
		// Log the error and throw a panic
		log.Panic(err)
	}
}

// A function that generates a pair of keys for the blockchain wallet
//
// The private key is generated from an ECDSA algorithm that uses the secp256r1 curve.
// The public key is generated by concatentanating the X,Y coordinates returned in the
// public key embedded within the ECDSA generated private key.
//
// This method of generating cryptographic key pairs creates a pair with 1 in 10^77 chance of collision.
func GenerateWalletKeys() (ecdsa.PrivateKey, []byte) {
	// Create a sepc256r1 elliptical curve
	curve := elliptic.P256()

	// Generate a set of keys with ECDSA algorithm
	key, err := ecdsa.GenerateKey(curve, rand.Reader)
	// Handle any potential errors
	Handle(err)

	// Construct the publio key by appending the Y coordinate bytes into the X coordinate slice
	public := append(key.PublicKey.X.Bytes(), key.PublicKey.Y.Bytes()...)

	// Return private and public keys
	return *key, public
}

// A function that generates double SHA256 hash of the
// given payload and returns it as a slice of bytes
func GenerateDoubleHash(payload []byte) []byte {
	// Hash the payload with SHA256 into the first layer
	firstlayer := sha256.Sum256(payload)
	// Hash the first layer with SHA256 into the second layer
	secondlayer := sha256.Sum256(firstlayer[:])
	// Return the hash
	return secondlayer[:]
}

// A function that truncates a given hash to the given length (in number of bytes)
// Returns the leftmost bytes of the original hash.
func TruncateHash(hash []byte, length int) []byte {
	return hash[:length]
}

// A function to encode a bytes payload into a Base58 bytes payload
func Base58Encode(payload []byte) []byte {
	// Encode the payload to base58
	encode := base58.Encode(payload)
	// Cast the encoded string to a slice of bytes and return it
	return []byte(encode)
}

// A function to decode a Base58 bytes payload into a regular bytes payload
func Base58Decode(encodeddata []byte) []byte {
	// Cast the base 58 encoded data into a string and decode it
	decode, err := base58.Decode(string(encodeddata[:]))
	// Handle any potential errors
	Handle(err)
	// Return the decoded bytes
	return decode
}

// A function that validates a given address by isolating its
// components and comparing the checksum of the address.
func ValidateWalletAddress(address string) bool {
	// Decode the address from base58 to get the public hash of the address
	publichash := Base58Decode([]byte(address))

	// Isolate the checksum from the public hash
	checksum := publichash[len(publichash)-4:]
	// Isolate the version from the public hash
	version := publichash[0]
	// Isolate the public key hash from the full public hash
	publichash = publichash[1 : len(publichash)-4]

	// Generate a new checksum from the version and public key hash
	targetsum := GeneratePublicKeyChecksum(append([]byte{version}, publichash...))
	// Check if the new checksum is equal to the check sum of the given address
	return bytes.Equal(checksum, targetsum)
}
