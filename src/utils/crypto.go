/*
This module contains the utility function that are used
for various hashing functionality
*/
package utils

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"

	"github.com/sirupsen/logrus"
)

/*
A function that generates a 256 bit hash
output for a given slice of bytes payload.
Generated by double hashing the payload

hash256 = SHA256(SHA256(payload))
*/
func Hash256(payload []byte) []byte {
	// Declare the hash byte array
	var hash [32]byte

	// Generate the hash of the payload
	hash = sha256.Sum256(payload)
	// Generate the hash of the hash
	hash = sha256.Sum256(hash[:])

	// Return the hash as slice
	return hash[:]
}

/*
A function that generates a 160bit hash
output for a given slice of bytes payload.
Generated by truncating a double hashed payload.

This is equivalent to the Bitcoin method of using SHA256 followed by RIPEMD160 and is equally safe.
The RIPEMD160 algorithm was rejected because of its deprecated nature in the Golang
crypto library along with the fact that truncated SHA2 algortithms are equally safe
Hence the choice to use truncated SHA256 over the SHA1 which also outputs 20 bytes.

hash160 = first20bytes[SHA256(SHA256(payload))]

References:
https://bitcoin.stackexchange.com/questions/16543/why-was-the-ripemd-160-hash-algorithms-chosen-before-sha-1
https://crypto.stackexchange.com/questions/3153/sha-256-vs-any-256-bits-of-sha-512-which-is-more-secure
*/
func Hash160(payload []byte) []byte {
	// Generate the 256 bit hash of the payload
	hash := Hash256(payload)
	// Truncate the hash to 20 bytes
	hash = hash[:20]

	// Return the hash
	return hash
}

/*
A function that generates a 32bit checksum
for a given slice of bytes payload.
Generated by truncating a double hashed payload.

checksum32 = first4bytes[SHA256(SHA256(payload))]
*/
func CheckSum32(payload []byte) []byte {
	// Generate the 256 bit hash of the payload
	hash := Hash256(payload)
	// Truncate the hash to 4 bytes
	checksum := hash[:4]

	// Return the checksum
	return checksum
}

/*
A function that generates a pair of digital
signature keys based on the ECDSA algorithm
using the secp256r1 elliptic curve.

This method of generating cryptographic key pairs
creates a pair with 1 in 10^77 chance of collision.
*/
func KeyGenECDSA() (ecdsa.PrivateKey, []byte) {
	// Create a sepc256r1 elliptical curve
	curve := elliptic.P256()

	// Generate a set of keys with ECDSA algorithm
	key, err := ecdsa.GenerateKey(curve, rand.Reader)
	// Handle any potential errors
	logrus.Fatal("ECDSA key generation failed!", err)

	// Construct the public key by appending the Y coordinate bytes into the X coordinate slice
	public := append(key.PublicKey.X.Bytes(), key.PublicKey.Y.Bytes()...)

	// Return private and public keys
	return *key, public
}
