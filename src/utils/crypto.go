/*
This module contains the utility function that are used
for various hashing functionality
*/
package utils

import (
	"crypto/sha256"
)

/*
A function that generates a 256 bit hash
output for a given slice of bytes payload.
Generated by double hashing the payload

hash256 = SHA256(SHA256(payload))
*/
func Hash256(payload []byte) []byte {
	// Declare the hash byte array
	var hash [32]byte

	// Generate the hash of the payload
	hash = sha256.Sum256(payload)
	// Generate the hash of the hash
	hash = sha256.Sum256(hash[:])

	// Return the hash as slice
	return hash[:]
}

/*
A function that generates a 160bit hash
output for a given slice of bytes payload.
Generated by truncating a double hashed payload.

This is equivalent to the Bitcoin method of using SHA256 followed by RIPEMD160 and is equally safe.
The RIPEMD160 algorithm was rejected because of its deprecated nature in the Golang
crypto library along with the fact that truncated SHA2 algortithms are equally safe
Hence the choice to use truncated SHA256 over the SHA1 which also outputs 20 bytes.

hash160 = first20bytes[SHA256(SHA256(payload))]

References:
https://bitcoin.stackexchange.com/questions/16543/why-was-the-ripemd-160-hash-algorithms-chosen-before-sha-1
https://crypto.stackexchange.com/questions/3153/sha-256-vs-any-256-bits-of-sha-512-which-is-more-secure
*/
func Hash160(payload []byte) []byte {
	// Generate the 256 bit hash of the payload
	hash := Hash256(payload)
	// Truncate the hash to 20 bytes
	hash = hash[:20]

	// Return the hash
	return hash
}

/*
A function that generates a 32bit checksum
for a given slice of bytes payload.
Generated by truncating a double hashed payload.

checksum32 = first4bytes[SHA256(SHA256(payload))]
*/
func CheckSum32(payload []byte) []byte {
	// Generate the 256 bit hash of the payload
	hash := Hash256(payload)
	// Truncate the hash to 4 bytes
	checksum := hash[:4]

	// Return the checksum
	return checksum
}
